name: Deploy preview on PR

on:
  pull_request:
    branches: [main]
    types: [opened, synchronize, reopened]

defaults:
  run:
    shell: 'bash -Eeuo pipefail {0}'

jobs:
  preview:
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read

    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-node@v4
        with:
          node-version: 'lts/*'
          cache: 'npm'

      - name: Install deps
        run: npm ci || npm install

      - name: Build
        env:
          VITE_FIREBASE_API_KEY:             ${{ secrets.VITE_FIREBASE_API_KEY }}
          VITE_FIREBASE_AUTH_DOMAIN:         ${{ secrets.VITE_FIREBASE_AUTH_DOMAIN }}
          VITE_FIREBASE_PROJECT_ID:          ${{ secrets.VITE_FIREBASE_PROJECT_ID }}
          VITE_FIREBASE_STORAGE_BUCKET:      ${{ secrets.VITE_FIREBASE_STORAGE_BUCKET }}
          VITE_FIREBASE_MESSAGING_SENDER_ID: ${{ secrets.VITE_FIREBASE_MESSAGING_SENDER_ID }}
          VITE_FIREBASE_APP_ID:              ${{ secrets.VITE_FIREBASE_APP_ID }}
          VITE_FIREBASE_MEASUREMENT_ID:      ${{ secrets.VITE_FIREBASE_MEASUREMENT_ID }} # optional
        run: npm run build

      - name: Auth to Google Cloud (WIF)
        uses: google-github-actions/auth@v2
        with:
          # Generate short‑lived credentials via Workload Identity Federation.
          # Creates a credentials file and exports env so Firebase CLI can use ADC.
          workload_identity_provider: projects/${{ secrets.GCP_PROJECT_NUMBER }}/locations/global/workloadIdentityPools/github-pool/providers/github-provider
          service_account: github-actions-deploy@um-shotbuilder.iam.gserviceaccount.com
          # Align with provider's Allowed audiences; commonly set to your repo URL.
          audience: https://github.com/ted-design/shot-builder-app
          create_credentials_file: true
          export_environment_variables: true

      - name: Deploy preview channel
        env:
          # Ensure Hosting predeploy (npm run build) gets the same env vars during deploy.
          VITE_FIREBASE_API_KEY:             ${{ secrets.VITE_FIREBASE_API_KEY }}
          VITE_FIREBASE_AUTH_DOMAIN:         ${{ secrets.VITE_FIREBASE_AUTH_DOMAIN }}
          VITE_FIREBASE_PROJECT_ID:          ${{ secrets.VITE_FIREBASE_PROJECT_ID }}
          VITE_FIREBASE_STORAGE_BUCKET:      ${{ secrets.VITE_FIREBASE_STORAGE_BUCKET }}
          VITE_FIREBASE_MESSAGING_SENDER_ID: ${{ secrets.VITE_FIREBASE_MESSAGING_SENDER_ID }}
          VITE_FIREBASE_APP_ID:              ${{ secrets.VITE_FIREBASE_APP_ID }}
          VITE_FIREBASE_MEASUREMENT_ID:      ${{ secrets.VITE_FIREBASE_MEASUREMENT_ID }} # optional
        # Channel name uses PR number (stable across pushes)
        # Set expiration to 3 days (instead of default 7) to help with quota management
        # Pipe through tee so CLI output still appears in the GitHub log when the command fails.
        run: |
          set -o pipefail
          npx firebase-tools@latest hosting:channel:deploy pr-${{ github.event.number }} \
            --project um-shotbuilder \
            --expires 3d \
            --json \
            --non-interactive \
            | tee deploy.json

          # Validate that deploy.json contains valid JSON, not HTML or error output
          if head -1 deploy.json | grep -qi '<!DOCTYPE\|<html'; then
            echo "ERROR: Deploy command returned HTML instead of JSON. Full output:"
            cat deploy.json
            exit 1
          fi

          # Verify JSON is parseable and check for success status
          if ! node -e "JSON.parse(require('fs').readFileSync('deploy.json', 'utf8'))" 2>/dev/null; then
            echo "ERROR: Deploy command returned invalid JSON. Full output:"
            cat deploy.json
            exit 1
          fi

      - name: Output preview URL
        run: |
          set -e
          echo "---- firebase-tools deploy output ----"
          cat deploy.json || true
          echo "--------------------------------------"

          node - <<'NODE'
          const fs = require('fs');

          // load deploy output first (often includes URLs)
          let url = null;
          try {
            const d = JSON.parse(fs.readFileSync('deploy.json', 'utf8'));
            // Try common locations for the URL
            // Newer CLIs often place it at deploys[0].url or result[0].url
            const candidates = [];
            if (Array.isArray(d.deploys)) candidates.push(...d.deploys);
            if (Array.isArray(d.result))  candidates.push(...d.result);
            if (d && d.result && d.result.previewUrl) candidates.push({ url: d.result.previewUrl });
            const found = candidates.find(x => x && x.url);
            if (found && found.url) url = found.url;
          } catch (_) {}

          // Fallback to channel list if not found in deploy output
          if (!url) {
            try {
              const child = require('child_process');
              const listJson = child.execSync('npx firebase-tools hosting:channel:list --project um-shotbuilder --json', { stdio: ['ignore', 'pipe', 'inherit'] }).toString();
              const o = JSON.parse(listJson);
              const pr = 'pr-${{ github.event.number }}';

              const channels = Array.isArray(o.result) ? o.result
                               : Array.isArray(o.channels) ? o.channels
                               : [];

              const match = channels.find(x => {
                const name = x && (x.name || '');
                return typeof name === 'string' && name.endsWith('/' + pr);
              });

              if (match && match.url) url = match.url;
            } catch (e) {
              console.log('Failed to query channel list:', e.message);
            }
          }

          if (url) {
            console.log('Preview URL:', url);
            // also write to the GitHub Step Summary so it’s visible on the PR
            fs.appendFileSync(process.env.GITHUB_STEP_SUMMARY, `**Preview URL:** ${url}\n`);
          } else {
            console.log('Preview deployed, but URL not found in CLI JSON.');
          }
          NODE

      - name: Cleanup old preview channels
        if: always()
        continue-on-error: true
        run: |
          # Production-grade cleanup with comprehensive error handling
          # Firebase auto-deletes expired channels within 24 hours (no prune command exists)
          # This cleanup is optional - deployment succeeds even if this step fails

          echo "::group::Fetching preview channel list"
          echo "Querying Firebase Hosting channels..."

          # Fetch channel list with proper error handling
          set +e  # Temporarily disable exit-on-error for this command
          CHANNELS_JSON=$(npx firebase-tools@latest hosting:channel:list \
            --project um-shotbuilder \
            --json 2>&1)
          FIREBASE_EXIT_CODE=$?
          set -e

          if [ $FIREBASE_EXIT_CODE -ne 0 ]; then
            echo "::warning::Failed to list channels (exit code: $FIREBASE_EXIT_CODE)"
            echo "Error output: $CHANNELS_JSON"
            echo "Skipping cleanup - this is non-critical"
            echo "::endgroup::"
            exit 0
          fi

          # Validate JSON response
          if echo "$CHANNELS_JSON" | grep -qi '<!DOCTYPE\|<html\|error\|unauthorized'; then
            echo "::warning::Received non-JSON response from Firebase CLI"
            echo "Response: $CHANNELS_JSON"
            echo "Skipping cleanup - this is non-critical"
            echo "::endgroup::"
            exit 0
          fi

          echo "Successfully fetched channel list"
          echo "::endgroup::"

          # Parse channels with robust error handling
          echo "::group::Analyzing channels for cleanup"

          # Write diagnostic output to stderr, channel IDs to stdout
          node -e "
            try {
              const data = JSON.parse(require('fs').readFileSync(0, 'utf-8'));

              // Handle different JSON response formats
              let channels = [];
              if (data.result && Array.isArray(data.result.channels)) {
                channels = data.result.channels;
              } else if (Array.isArray(data.result)) {
                channels = data.result;
              } else if (Array.isArray(data.channels)) {
                channels = data.channels;
              }

              console.error('Total channels found: ' + channels.length);

              // Keep 15 most recent channels (generous buffer below 50 limit)
              // Sort by createTime (oldest first)
              channels.sort((a, b) => {
                const timeA = new Date(a.createTime || 0).getTime();
                const timeB = new Date(b.createTime || 0).getTime();
                return timeA - timeB;
              });

              const keepCount = 15;
              const toDelete = channels.slice(0, Math.max(0, channels.length - keepCount));

              console.error('Channels to keep: ' + Math.min(channels.length, keepCount));
              console.error('Channels to delete: ' + toDelete.length);

              // Extract channel ID from full path
              toDelete.forEach(ch => {
                if (ch.name) {
                  const channelId = ch.name.split('/').pop();
                  const expireTime = ch.expireTime ? new Date(ch.expireTime).toISOString() : 'unknown';
                  console.error('  - ' + channelId + ' (expires: ' + expireTime + ')');
                  console.log(channelId);
                }
              });
            } catch (err) {
              console.error('Error parsing channel data: ' + err.message);
              process.exit(0);  // Exit successfully - cleanup is optional
            }
          " <<< "$CHANNELS_JSON" > /tmp/channels_to_delete.txt

          CHANNEL_IDS=$(cat /tmp/channels_to_delete.txt)

          echo "::endgroup::"

          # Delete old channels
          if [ -n "$CHANNEL_IDS" ]; then
            echo "::group::Deleting old preview channels"
            echo "$CHANNEL_IDS" | while IFS= read -r CHANNEL_ID; do
              if [ -n "$CHANNEL_ID" ]; then
                echo "Deleting channel: $CHANNEL_ID"
                set +e
                npx firebase-tools@latest hosting:channel:delete "$CHANNEL_ID" \
                  --project um-shotbuilder \
                  --force 2>&1
                DELETE_EXIT_CODE=$?
                set -e

                if [ $DELETE_EXIT_CODE -eq 0 ]; then
                  echo "  ✓ Successfully deleted $CHANNEL_ID"
                else
                  echo "  ⚠ Failed to delete $CHANNEL_ID (may not exist) - continuing"
                fi
              fi
            done
            echo "::endgroup::"
            echo "✓ Cleanup completed"
          else
            echo "No old channels to delete - all channels are recent"
          fi
