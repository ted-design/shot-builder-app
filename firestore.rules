rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    function isAuthed() {
      return request.auth != null;
    }

    function userClient() {
      return request.auth != null
        ? (request.auth.token.clientId != null
            ? request.auth.token.clientId
            : request.auth.token.orgId)
        : null;
    }

    function clientMatches(pathClient) {
      let clientId = userClient();
      return clientId != null && clientId == pathClient;
    }

    function isAdmin() {
      // Support case variations (Admin, admin, ADMIN)
      let role = request.auth.token.role;
      return request.auth != null &&
        (role == 'admin' || role == 'Admin' || role == 'ADMIN');
    }

    function isProducer() {
      // Support case variations for producer, wardrobe, and warehouse roles
      let role = request.auth.token.role;
      return request.auth != null &&
        (role == 'producer' || role == 'Producer' || role == 'PRODUCER' ||
         role == 'wardrobe' || role == 'Wardrobe' || role == 'WARDROBE' ||
         role == 'warehouse' || role == 'Warehouse' || role == 'WAREHOUSE');
    }

    function hasProjectRole(projectId, roles) {
      let clientId = userClient();
      let memberPath = /databases/$(database)/documents/clients/$(clientId)/projects/$(projectId)/members/$(request.auth.uid);
      let memberRole = exists(memberPath) ? get(memberPath).data.role : null;
      // Normalize role to lowercase for comparison
      // Both 'wardrobe' and 'warehouse' normalize to canonical 'warehouse' (matching TypeScript Role type)
      let normalizedRole = memberRole == 'Producer' ? 'producer'
        : memberRole == 'PRODUCER' ? 'producer'
        : memberRole == 'Wardrobe' ? 'warehouse'
        : memberRole == 'WARDROBE' ? 'warehouse'
        : memberRole == 'wardrobe' ? 'warehouse'
        : memberRole == 'Warehouse' ? 'warehouse'
        : memberRole == 'WAREHOUSE' ? 'warehouse'
        : memberRole == 'Viewer' ? 'viewer'
        : memberRole == 'VIEWER' ? 'viewer'
        : memberRole == 'Crew' ? 'crew'
        : memberRole == 'CREW' ? 'crew'
        : memberRole;
      return clientId != null &&
        request.auth != null &&
        memberRole != null &&
        roles.hasAny([normalizedRole]);
    }

    function isSystemAdmin() {
      return request.auth != null &&
        exists(/databases/$(database)/documents/systemAdmins/$(request.auth.token.email)) &&
        get(/databases/$(database)/documents/systemAdmins/$(request.auth.token.email)).data.enabled == true;
    }

    // System Admins - managed via Cloud Functions and admin scripts
    match /systemAdmins/{email} {
      // Only system admins can read the list of system admins
      allow read: if isSystemAdmin();
      // Only Cloud Functions can write (via Admin SDK)
      allow write: if false;
    }

    // Public pull sharing via collection group queries
    // This wildcard rule allows unauthenticated users to query pulls across all clients/projects
    // when a valid shareToken is provided
    match /{path=**}/pulls/{pullId} {
      // Allow unauthenticated collection group queries when sharing is enabled
      // Security: Requires knowledge of the exact cryptographic shareToken (32+ chars)
      // The client queries: collectionGroup('pulls').where('shareToken', '==', token).where('shareEnabled', '==', true)
      allow list, get: if resource.data.shareEnabled == true;
    }

    // Public shot sharing â€” share docs live at /shotShares/{shareToken} (doc id = token).
    // Resolved shot data is denormalized into the doc at creation time.
    match /shotShares/{shareToken} {
      // Allow unauthenticated get when sharing is enabled and not expired.
      // Security: Requires knowledge of the exact share token (UUID / 32+ chars).
      allow get: if resource.data.enabled == true
        && (resource.data.expiresAt == null || resource.data.expiresAt > request.time);

      // Authenticated admin/producer reads (management UI)
      allow get, list: if isAuthed() &&
        (isAdmin() || isProducer()) &&
        resource.data.clientId == userClient();

      allow create: if isAuthed() &&
        (isAdmin() || isProducer()) &&
        request.resource.data.clientId == userClient() &&
        request.resource.data.projectId is string &&
        (request.resource.data.shotIds == null || request.resource.data.shotIds is list) &&
        request.resource.data.enabled is bool;

      allow update, delete: if isAuthed() &&
        (isAdmin() || isProducer()) &&
        resource.data.clientId == userClient();
    }

    // LEGACY COLLECTIONS - DEPRECATED
    // These root-level collections are no longer used in the application.
    // All data has been migrated to client-scoped collections under /clients/{clientId}/
    // Keeping these rules disabled to prevent accidental access to legacy data.
    // If you need to access legacy data for migration, temporarily enable with client matching.

    // match /talent/{docId} {
    //   allow read: if false;  // Explicitly deny all access
    //   allow write: if false;
    // }

    // match /locations/{docId} {
    //   allow read: if false;  // Explicitly deny all access
    //   allow write: if false;
    // }

    // match /shots/{docId} {
    //   allow read: if false;  // Explicitly deny all access
    //   allow write: if false;
    // }

	    match /clients/{clientId}/talent/{docId} {
	      allow read: if clientMatches(clientId);
	      allow create, update, delete: if clientMatches(clientId) && isAuthed();

      // Versions - immutable document snapshots for version history
      match /versions/{versionId} {
        allow read: if clientMatches(clientId);
        allow create: if clientMatches(clientId) && isAuthed() &&
          request.resource.data.createdBy == request.auth.uid;
        allow update, delete: if false; // Versions are immutable
      }

      // Presence - field-level locking for collaborative editing
      match /presence {
        allow read: if clientMatches(clientId);
        allow write: if clientMatches(clientId) && isAuthed();
      }
    }

    match /clients/{clientId}/locations/{docId} {
      allow read: if clientMatches(clientId);
      allow create, update, delete: if clientMatches(clientId) && isAuthed();

      // Versions - immutable document snapshots for version history
      match /versions/{versionId} {
        allow read: if clientMatches(clientId);
        allow create: if clientMatches(clientId) && isAuthed() &&
          request.resource.data.createdBy == request.auth.uid;
        allow update, delete: if false; // Versions are immutable
      }

      // Presence - field-level locking for collaborative editing
      match /presence {
        allow read: if clientMatches(clientId);
        allow write: if clientMatches(clientId) && isAuthed();
	      }
	    }

	    // Crew - org-level crew directory (used by projects for assignments)
	    match /clients/{clientId}/crew/{crewMemberId} {
	      allow read: if clientMatches(clientId) && isAuthed();
	      allow create, update, delete: if clientMatches(clientId) &&
	        (isAdmin() || isProducer());
	    }

	    match /clients/{clientId}/shots/{docId} {
	      allow read: if clientMatches(clientId);
	      allow create, update, delete: if clientMatches(clientId) && isAuthed();

      // Comments - subcollection of shots for collaboration
      match /comments/{commentId} {
        // Anyone with shot read access can read comments
        allow read: if clientMatches(clientId) && isAuthed();

        // Any authenticated client user can create comments
        allow create: if clientMatches(clientId) && isAuthed() &&
          request.resource.data.createdBy == request.auth.uid;

        // Only comment author can update their own comment
        // Prevent modification of immutable fields
        allow update: if clientMatches(clientId) && isAuthed() &&
          resource.data.createdBy == request.auth.uid &&
          request.resource.data.createdBy == resource.data.createdBy &&
          request.resource.data.createdAt == resource.data.createdAt &&
          request.resource.data.createdByName == resource.data.createdByName &&
          request.resource.data.createdByAvatar == resource.data.createdByAvatar;

        // Only comment author can delete (soft delete) their own comment
        allow delete: if clientMatches(clientId) && isAuthed() &&
          resource.data.createdBy == request.auth.uid;
      }

      // Versions - immutable document snapshots for version history
      match /versions/{versionId} {
        allow read: if clientMatches(clientId);
        allow create: if clientMatches(clientId) && isAuthed() &&
          request.resource.data.createdBy == request.auth.uid;
        allow update, delete: if false; // Versions are immutable
      }

      // Presence - field-level locking for collaborative editing
      match /presence {
        allow read: if clientMatches(clientId);
        allow write: if clientMatches(clientId) && isAuthed();
      }
    }

    // Notifications - users can only read/update/delete their own notifications
    match /clients/{clientId}/notifications/{notificationId} {
      allow read: if clientMatches(clientId) && isAuthed() &&
        resource.data.userId == request.auth.uid;
      allow create: if clientMatches(clientId) && isAuthed() &&
        request.resource.data.userId is string;
      allow update, delete: if clientMatches(clientId) && isAuthed() &&
        resource.data.userId == request.auth.uid;
    }

    // User profiles - users can read their own profile and other users in their client
    match /clients/{clientId}/users/{userId} {
      allow read: if clientMatches(clientId) && isAuthed();
      allow create: if clientMatches(clientId) && isAuthed() && request.auth.uid == userId;
      allow update: if clientMatches(clientId) && (isAdmin() || request.auth.uid == userId);
      allow delete: if clientMatches(clientId) && isAdmin();
    }

    // Wildcard rule for client-scoped collections
    // Restricts read access to admin users only to prevent unauthorized data access
    // Specific collections have more granular rules defined below
    match /clients/{clientId}/{document=**} {
      allow read: if clientMatches(clientId) && isAdmin();
    }

    match /clients/{clientId}/products/{productId} {
      allow read: if clientMatches(clientId);
      allow create, delete: if clientMatches(clientId) && isAdmin();
      allow update: if clientMatches(clientId) &&
        (isAdmin() || isProducer());
    }

    match /clients/{clientId}/productFamilies/{familyId} {
      allow read: if clientMatches(clientId);
      allow create, update: if clientMatches(clientId) && (isAdmin() || isProducer());
      allow delete: if clientMatches(clientId) && isAdmin();

      match /skus/{skuId} {
        allow read: if clientMatches(clientId);
        allow create, update: if clientMatches(clientId) && (isAdmin() || isProducer());
        allow delete: if clientMatches(clientId) && isAdmin();
      }

      // Samples - supply tracking (shoot / pre-production / bulk)
      match /samples/{sampleId} {
        allow read: if clientMatches(clientId) && isAuthed();
        allow create, update, delete: if clientMatches(clientId) && (isAdmin() || isProducer());
      }

      // Documents - tech packs, spec sheets, supporting materials
      match /documents/{documentId} {
        allow read: if clientMatches(clientId) && isAuthed();
        allow create, update, delete: if clientMatches(clientId) && (isAdmin() || isProducer());
      }

      // Comments - discussion thread on a product family
      match /comments/{commentId} {
        allow read: if clientMatches(clientId) && isAuthed();

        allow create: if clientMatches(clientId) && isAuthed() &&
          request.resource.data.createdBy == request.auth.uid;

        // Only comment author can update their own comment.
        // Prevent modification of immutable fields.
        allow update: if clientMatches(clientId) && isAuthed() &&
          resource.data.createdBy == request.auth.uid &&
          request.resource.data.createdBy == resource.data.createdBy &&
          request.resource.data.createdAt == resource.data.createdAt &&
          request.resource.data.createdByName == resource.data.createdByName &&
          request.resource.data.createdByAvatar == resource.data.createdByAvatar;

        // Allow hard delete by the author (UI uses soft-delete via update).
        allow delete: if clientMatches(clientId) && isAuthed() &&
          resource.data.createdBy == request.auth.uid;
      }

      // Versions - immutable document snapshots for version history
      match /versions/{versionId} {
        allow read: if clientMatches(clientId);
        allow create: if clientMatches(clientId) && isAuthed() &&
          request.resource.data.createdBy == request.auth.uid;
        allow update, delete: if false; // Versions are immutable
      }

      // Presence - field-level locking for collaborative editing
      match /presence {
        allow read: if clientMatches(clientId);
        allow write: if clientMatches(clientId) && isAuthed();
      }
    }

    // Color swatches - org-level palette for standardizing product colors
    match /clients/{clientId}/colorSwatches/{swatchId} {
      allow read: if clientMatches(clientId);
      allow create, update: if clientMatches(clientId) && (isAdmin() || isProducer());
      allow delete: if clientMatches(clientId) && isAdmin();
    }

    // Product classifications - org-level taxonomy for product type/subcategory controls
    match /clients/{clientId}/productClassifications/{classificationId} {
      allow read: if clientMatches(clientId);
      allow create, update: if clientMatches(clientId) && (isAdmin() || isProducer());
      allow delete: if clientMatches(clientId) && isAdmin();
    }

	    match /clients/{clientId}/projects/{projectId} {
	      allow read: if clientMatches(clientId) &&
	        (isAdmin() || hasProjectRole(projectId, ['producer', 'warehouse', 'viewer']));
	      allow create: if clientMatches(clientId) && (isAdmin() || isProducer());
	      allow update, delete: if clientMatches(clientId) &&
	        (isAdmin() || isProducer() || hasProjectRole(projectId, ['producer', 'warehouse']));

	      // Project departments and positions (project-scoped role taxonomy)
	      match /departments/{departmentId} {
	        allow read: if clientMatches(clientId) &&
	          (isAdmin() || hasProjectRole(projectId, ['producer', 'warehouse', 'viewer']));
	        allow create, update, delete: if clientMatches(clientId) &&
	          (isAdmin() || hasProjectRole(projectId, ['producer', 'warehouse']));

	        match /positions/{positionId} {
	          allow read: if clientMatches(clientId) &&
	            (isAdmin() || hasProjectRole(projectId, ['producer', 'warehouse', 'viewer']));
	          allow create, update, delete: if clientMatches(clientId) &&
	            (isAdmin() || hasProjectRole(projectId, ['producer', 'warehouse']));
	        }
	      }

	      // Pulls - project-specific access for authenticated users
	      // Public sharing is handled by the top-level wildcard rule
	      match /pulls/{pullId} {
	        // Authenticated users with proper role
	        allow read, write: if clientMatches(clientId) &&
          (isAdmin() || hasProjectRole(projectId, ['producer', 'warehouse', 'viewer']));
      }

      // Activities - project activity feed with 90-day retention
      match /activities/{activityId} {
        // Anyone with project read access can read activities
        allow read: if clientMatches(clientId) &&
          (isAdmin() || hasProjectRole(projectId, ['producer', 'warehouse', 'viewer']));

        // Only authenticated users with project access can create activities
        // Validate that actorId matches authenticated user
        allow create: if clientMatches(clientId) && isAuthed() &&
          request.resource.data.actorId == request.auth.uid &&
          request.resource.data.projectId == projectId;

        // Activities are immutable - no updates allowed (audit trail integrity)
        allow update: if false;

        // Only admins can delete activities (for cleanup/retention purposes)
        allow delete: if clientMatches(clientId) && isAdmin();
      }

      // Schedules - call sheet scheduling for projects
      match /schedules/{scheduleId} {
        // Anyone with project access can read schedules
        allow read: if clientMatches(clientId) &&
          (isAdmin() || hasProjectRole(projectId, ['producer', 'warehouse', 'viewer']));

        // Producers and above can create/update schedules
        allow create, update: if clientMatches(clientId) &&
          (isAdmin() || hasProjectRole(projectId, ['producer', 'warehouse']));

        // Only admins can delete schedules
        allow delete: if clientMatches(clientId) && isAdmin();

        // Schedule entries - individual items on the schedule
        match /entries/{entryId} {
          // Anyone with project access can read entries
          allow read: if clientMatches(clientId) &&
            (isAdmin() || hasProjectRole(projectId, ['producer', 'warehouse', 'viewer']));

          // Producers and above can create/update/delete entries
          allow create, update, delete: if clientMatches(clientId) &&
            (isAdmin() || hasProjectRole(projectId, ['producer', 'warehouse']));
        }

        // Day details - call times, notes, weather (per schedule)
        match /dayDetails/{detailId} {
          allow read: if clientMatches(clientId) &&
            (isAdmin() || hasProjectRole(projectId, ['producer', 'warehouse', 'viewer']));
          allow create, update, delete: if clientMatches(clientId) &&
            (isAdmin() || hasProjectRole(projectId, ['producer', 'warehouse']));
        }

        // Talent call overrides (per schedule)
        match /talentCalls/{talentId} {
          allow read: if clientMatches(clientId) &&
            (isAdmin() || hasProjectRole(projectId, ['producer', 'warehouse', 'viewer']));
          allow create, update, delete: if clientMatches(clientId) &&
            (isAdmin() || hasProjectRole(projectId, ['producer', 'warehouse']));
        }

        // Crew call overrides (per schedule)
        match /crewCalls/{crewMemberId} {
          allow read: if clientMatches(clientId) &&
            (isAdmin() || hasProjectRole(projectId, ['producer', 'warehouse', 'viewer']));
          allow create, update, delete: if clientMatches(clientId) &&
            (isAdmin() || hasProjectRole(projectId, ['producer', 'warehouse']));
        }

        // Client call rows (per schedule)
        match /clientCalls/{clientCallId} {
          allow read: if clientMatches(clientId) &&
            (isAdmin() || hasProjectRole(projectId, ['producer', 'warehouse', 'viewer']));
          allow create, update, delete: if clientMatches(clientId) &&
            (isAdmin() || hasProjectRole(projectId, ['producer', 'warehouse']));
        }

        // Call sheet builder state (config/layout/templates) for a schedule.
        match /callSheet/{docId} {
          allow read: if clientMatches(clientId) &&
            (isAdmin() || hasProjectRole(projectId, ['producer', 'warehouse', 'viewer']));
          allow create, update, delete: if clientMatches(clientId) &&
            (isAdmin() || hasProjectRole(projectId, ['producer', 'warehouse']));
        }
      }

      match /{collectionId}/{docId} {
        allow read: if clientMatches(clientId) &&
          (isAdmin() || hasProjectRole(projectId, ['producer', 'warehouse', 'viewer']));
        allow create, update, delete: if clientMatches(clientId) &&
          (isAdmin() || hasProjectRole(projectId, ['producer', 'warehouse']));
      }
    }
  }
}
